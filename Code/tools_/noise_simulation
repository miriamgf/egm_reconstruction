import sys, os

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from scipy.io import loadmat
import numpy as np
from random import randint
import matplotlib.pyplot as plt
from itertools import product
from numpy.random import default_rng
import scipy.io
import h5py
from scipy import signal as sigproc
from scipy.interpolate import interp1d
from math import floor
from scipy import signal
from add_white_noise import *
from fastdtw import fastdtw
from scipy.spatial.distance import euclidean
import tensorflow as tf
import random
import math
from sklearn.metrics import mean_squared_error
from fastdtw import fastdtw
import time
import keras
from keras import models, layers
import pandas as pd
from sklearn.model_selection import train_test_split, StratifiedKFold
from tensorflow.keras import datasets, layers, models, losses, Model
from generators import *
from numpy import reshape
import matplotlib.image
from scipy.io import savemat
from plots import *
from scipy.stats import pearsonr
from scipy.stats import spearmanr
from datetime import time
import wfdb



# %% Path Models
# %% Path Models
current = os.path.dirname(os.path.realpath(__file__))
torsos_dir = "../../../Labeled_torsos/"
directory = "/home/profes/miriamgf/tesis/Autoencoders/Data/"
torsos_dir = "/home/profes/miriamgf/tesis/Autoencoders/Labeled_torsos/"

class NoiseSimulation:

    def __init__(self, signal, SNR_electrode_noise = 20, SNR_white_noise=20, oclusion =None, fs):

        self.signal = signal
        self.SNR_electrode_noise = True
        self.SNR_white_noise = True
        self.fs = fs
    
    def add_white_noise(X, SNR=20, fs=50):

        X_noisy, _ = addwhitenoise(X, SNR=SNR, fs=fs)

        # Normalizar
        # mm = np.mean(X_noisy, axis=0)
        # ss = np.std(X_noisy, axis=0)
        # X_noisy_normalized = (X_noisy - mm[np.newaxis,:]) / ss[np.newaxis,:]
        # X_noisy_normalized=  X_noisy

        return X_noisy 

    def add_electrode_noise(X,  SNR=20, fs=fs):

        num_electrodes = X.shape[0]
    
    def load_physionet_signals(type_noise='em'):
        database = 'mitdb'     # Nombre de la base de datos en PhysioNet
        record_name = type_noise  # Nombre del registro
        record = wfdb.rdrecord(f'{database}/{record_name}', sampfrom=self.fs, channels=[0])
        noise = record.p_signal
        return noise
    
    def add_noise(X):


        






